{
  "id": "120",
  "name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
  "abstraction": "Base",
  "structure": "Simple",
  "status": "Incomplete",
  "description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
  "extended_description": "A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the \"classic\" case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",
  "related_weaknesses": [
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1000",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1003",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1305",
      "ordinal": "Primary"
    },
    {
      "nature": "ChildOf",
      "cweid": "119",
      "view_id": "1340",
      "ordinal": "Primary"
    },
    {
      "nature": "CanPrecede",
      "cweid": "123",
      "view_id": "1000"
    },
    {
      "nature": "ChildOf",
      "cweid": "20",
      "view_id": "700",
      "ordinal": "Primary"
    }
  ],
  "applicable_platforms": {
    "language": [
      {
        "prevalence": "Undetermined",
        "name": "C"
      },
      {
        "prevalence": "Undetermined",
        "name": "C++"
      },
      {
        "class": "Assembly",
        "prevalence": "Undetermined"
      }
    ]
  },
  "modes_of_introduction": [
    {
      "phase": "Implementation"
    }
  ],
  "likelihood_of_exploit": "High",
  "common_consequences": [
    {
      "scope": [
        "Integrity",
        "Confidentiality",
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "Execute Unauthorized Code or Commands"
      ],
      "note": "Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of the product's implicit security policy. This can often be used to subvert any other security service."
    },
    {
      "scope": [
        "Availability"
      ],
      "impact": [
        "Modify Memory",
        "DoS: Crash, Exit, or Restart",
        "DoS: Resource Consumption (CPU)"
      ],
      "note": "Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the product into an infinite loop."
    }
  ],
  "potential_mitigations": [
    {
      "mitigation_id": "MIT-3",
      "phase": [
        "Requirements"
      ],
      "description": [
        "\n                  <xhtml:p>Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.</xhtml:p>\n                  <xhtml:p>For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer.</xhtml:p>\n                  <xhtml:p>Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.</xhtml:p>\n               "
      ],
      "strategy": "Language Selection"
    },
    {
      "mitigation_id": "MIT-4.1",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "\n                  <xhtml:p>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.</xhtml:p>\n                  <xhtml:p>Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.</xhtml:p>\n               "
      ],
      "effectiveness_notes": "This is not a complete solution, since many buffer overflows are not related to strings.",
      "strategy": "Libraries or Frameworks"
    },
    {
      "mitigation_id": "MIT-10",
      "phase": [
        "Operation",
        "Build and Compilation"
      ],
      "description": [
        " \n\t\t<xhtml:p>Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. </xhtml:p> \n\t\t<xhtml:p> D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. </xhtml:p> \n\n\t      "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": " \n\t\t \n\t      ",
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-9",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  <xhtml:p>Consider adhering to the following rules when allocating and managing an application's memory:</xhtml:p>\n                     <xhtml:ul>\n                        <xhtml:li>Double check that your buffer is as large as you specify.</xhtml:li>\n                        <xhtml:li>When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string.</xhtml:li>\n                        <xhtml:li>Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space.</xhtml:li>\n                        <xhtml:li>If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.</xhtml:li>\n                     </xhtml:ul>\n               "
      ]
    },
    {
      "mitigation_id": "MIT-5",
      "phase": [
        "Implementation"
      ],
      "description": [
        "\n                  <xhtml:p>Assume all input is malicious. Use an \"accept known good\" input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does.</xhtml:p>\n                  <xhtml:p>When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, \"boat\" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as \"red\" or \"blue.\"</xhtml:p>\n                  <xhtml:p>Do not rely exclusively on looking for malicious or malformed inputs.  This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.</xhtml:p>\n               "
      ],
      "strategy": "Input Validation"
    },
    {
      "mitigation_id": "MIT-15",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      ]
    },
    {
      "mitigation_id": "MIT-11",
      "phase": [
        "Operation",
        "Build and Compilation"
      ],
      "description": [
        "\n\t\t <xhtml:p>Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. </xhtml:p> \n\t\t <xhtml:p> Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. </xhtml:p> \n\t\t <xhtml:p> For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. </xhtml:p>\n\t       "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "These techniques do not provide a complete solution.  For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333]",
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-12",
      "phase": [
        "Operation"
      ],
      "description": [
        " \n\t\t <xhtml:p> Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment.  </xhtml:p> \n\t         <xhtml:p> For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. </xhtml:p>\n\t       "
      ],
      "effectiveness": "Defense in Depth",
      "effectiveness_notes": "This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application. ",
      "strategy": "Environment Hardening"
    },
    {
      "phase": [
        "Build and Compilation",
        "Operation"
      ],
      "description": [
        "Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution."
      ]
    },
    {
      "mitigation_id": "MIT-13",
      "phase": [
        "Implementation"
      ],
      "description": [
        "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available."
      ],
      "effectiveness": "Moderate",
      "effectiveness_notes": "This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131)."
    },
    {
      "mitigation_id": "MIT-21",
      "phase": [
        "Architecture and Design"
      ],
      "description": [
        "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      ],
      "strategy": "Enforcement by Conversion"
    },
    {
      "mitigation_id": "MIT-17",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      ],
      "strategy": "Environment Hardening"
    },
    {
      "mitigation_id": "MIT-22",
      "phase": [
        "Architecture and Design",
        "Operation"
      ],
      "description": [
        "\n                  <xhtml:p>Run the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software.</xhtml:p>\n                  <xhtml:p>OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations.</xhtml:p>\n                  <xhtml:p>This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise.</xhtml:p>\n                  <xhtml:p>Be careful to avoid CWE-243 and other weaknesses related to jails.</xhtml:p>\n               "
      ],
      "effectiveness": "Limited",
      "effectiveness_notes": "The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed.",
      "strategy": "Sandbox or Jail"
    }
  ],
  "demonstrative_examples": [
    {
      "text": "\n               <Intro_Text>The following code asks the user to enter their last name and then attempts to store the value entered in the last_name array.</Intro_Text>\n               <Example_Code Nature=\"Bad\" Language=\"C\">\n                  <xhtml:div>char last_name[20];<xhtml:br/>printf (\"Enter your last name: \");<xhtml:br/>scanf (\"%s\", last_name);</xhtml:div>\n               </Example_Code>\n               <Body_Text>The problem with the code above is that it does not restrict or limit the size of the name entered by the user. If the user enters \"Very_very_long_last_name\" which is 24 characters long, then a buffer overflow will occur since the array can only hold 20 characters total.</Body_Text>\n            "
    },
    {
      "demonstrative_example_id": "DX-6",
      "text": "\n               <Intro_Text>The following code attempts to create a local copy of a buffer to perform some manipulations to the data.</Intro_Text>\n               <Example_Code Nature=\"Bad\" Language=\"C\">\n                  <xhtml:div>void manipulate_string(char * string){<xhtml:div style=\"margin-left:1em;\">char buf[24];<xhtml:br/>strcpy(buf, string);<xhtml:br/>...</xhtml:div>}</xhtml:div>\n               </Example_Code>\n               <Body_Text>However, the programmer does not ensure that the size of the data pointed to by string will fit in the local buffer and copies the data with the potentially dangerous strcpy() function. This may result in a buffer overflow condition if an attacker can influence the contents of the string parameter.</Body_Text>\n            "
    },
    {
      "demonstrative_example_id": "DX-5",
      "text": "\n               <Intro_Text>The code below calls the gets() function to read in data from the command line.</Intro_Text>\n               <Example_Code Nature=\"Bad\" Language=\"C\">\n                  <xhtml:div>\n                     <xhtml:div style=\"margin-left:1em;\">char buf[24];<xhtml:br/>printf(\"Please enter your name and press &lt;Enter&gt;\\n\");<xhtml:br/>gets(buf);<xhtml:br/>...</xhtml:div>}</xhtml:div>\n               </Example_Code>\n               <Body_Text>However, gets() is inherently unsafe, because it copies all input from STDIN to the buffer without checking size. This allows the user to provide a string that is larger than the buffer size, resulting in an overflow condition.</Body_Text>\n            "
    },
    {
      "text": "\n               <Intro_Text>In the following example, a server accepts connections from a client and processes the client request. After accepting a client connection, the program will obtain client information using the gethostbyaddr method, copy the hostname of the client that connected to a local variable and output the hostname of the client to a log file.</Intro_Text>\n               <Example_Code Nature=\"Bad\" Language=\"C\">\n                  <xhtml:div>...<xhtml:div style=\"margin-left:1em;\">\n                        <xhtml:div>struct hostent *clienthp;<xhtml:br/>char hostname[MAX_LEN];<xhtml:br/>\n                           <xhtml:br/>// create server socket, bind to server address and listen on socket<xhtml:br/>...<xhtml:br/>\n                           <xhtml:br/>// accept client connections and process requests<xhtml:br/>int count = 0;<xhtml:br/>for (count = 0; count &lt; MAX_CONNECTIONS; count++) {<xhtml:div style=\"margin-left:1em;\">\n                              <xhtml:div>\n                                 <xhtml:br/>int clientlen = sizeof(struct sockaddr_in);<xhtml:br/>int clientsocket = accept(serversocket, (struct sockaddr *)&amp;clientaddr, &amp;clientlen);<xhtml:br/>\n                                 <xhtml:br/>if (clientsocket &gt;= 0) {<xhtml:div style=\"margin-left:1em;\">\n                                    <xhtml:div>clienthp = gethostbyaddr((char*) &amp;clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);<xhtml:br/>strcpy(hostname, clienthp-&gt;h_name);<xhtml:br/>logOutput(\"Accepted client connection from host \", hostname);<xhtml:br/>\n                                       <xhtml:br/>// process client request<xhtml:br/>...<xhtml:br/>close(clientsocket);</xhtml:div>\n                                 </xhtml:div>}</xhtml:div>\n                           </xhtml:div>}<xhtml:br/>close(serversocket);</xhtml:div>\n                     </xhtml:div>\n                     <xhtml:br/>...</xhtml:div>\n               </Example_Code>\n               <Body_Text>However, the hostname of the client that connected may be longer than the allocated size for the local hostname variable. This will result in a buffer overflow when copying the client hostname to the local variable using the strcpy method.</Body_Text>\n            "
    }
  ],
  "observed_examples": [
    {
      "reference": "CVE-2000-1094",
      "description": "buffer overflow using command with long argument",
      "link": "https://www.cve.org/CVERecord?id=CVE-2000-1094"
    },
    {
      "reference": "CVE-1999-0046",
      "description": "buffer overflow in local program using long environment variable",
      "link": "https://www.cve.org/CVERecord?id=CVE-1999-0046"
    },
    {
      "reference": "CVE-2002-1337",
      "description": "buffer overflow in comment characters, when product increments a counter for a \">\" but does not decrement for \"<\"",
      "link": "https://www.cve.org/CVERecord?id=CVE-2002-1337"
    },
    {
      "reference": "CVE-2003-0595",
      "description": "By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.",
      "link": "https://www.cve.org/CVERecord?id=CVE-2003-0595"
    },
    {
      "reference": "CVE-2001-0191",
      "description": "By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.",
      "link": "https://www.cve.org/CVERecord?id=CVE-2001-0191"
    }
  ],
  "references": [
    {
      "section": "Chapter 5, \"Public Enemy #1: The Buffer Overrun\" Page 127",
      "reference_id": "REF-7",
      "author": [
        "Michael Howard",
        "David LeBlanc"
      ],
      "title": "Writing Secure Code",
      "url": "https://www.microsoftpressstore.com/store/writing-secure-code-9780735617223",
      "publication_year": "2002",
      "publication_month": "--12",
      "publication_day": "---04",
      "publisher": "Microsoft Press",
      "edition": "2nd Edition"
    },
    {
      "section": "\"Sin 5: Buffer Overruns.\" Page 89",
      "reference_id": "REF-44",
      "author": [
        "Michael Howard",
        "David LeBlanc",
        "John Viega"
      ],
      "title": "24 Deadly Sins of Software Security",
      "publication_year": "2010",
      "publication": "McGraw-Hill"
    },
    {
      "reference_id": "REF-56",
      "author": [
        "Microsoft"
      ],
      "title": "Using the Strsafe.h Functions",
      "url": "https://learn.microsoft.com/en-us/windows/win32/menurc/strsafe-ovw?redirectedfrom=MSDN",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-57",
      "author": [
        "Matt Messier",
        "John Viega"
      ],
      "title": "Safe C String Library v1.0.3",
      "url": "http://www.gnu-darwin.org/www001/ports-1.5a-CURRENT/devel/safestr/work/safestr-1.0.3/doc/safestr.html",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-58",
      "author": [
        "Michael Howard"
      ],
      "title": "Address Space Layout Randomization in Windows Vista",
      "url": "https://learn.microsoft.com/en-us/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-59",
      "author": [
        "Arjan van de Ven"
      ],
      "title": "Limiting buffer overflows with ExecShield",
      "url": "https://archive.is/saAFo",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-60",
      "title": "PaX",
      "url": "https://en.wikipedia.org/wiki/Executable_space_protection#PaX",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-74",
      "author": [
        "Jason Lam"
      ],
      "title": "Top 25 Series - Rank 3 - Classic Buffer Overflow",
      "url": "http://software-security.sans.org/blog/2010/03/02/top-25-series-rank-3-classic-buffer-overflow/",
      "publication_year": "2010",
      "publication_month": "--03",
      "publication_day": "---02",
      "publisher": "SANS Software Security Institute"
    },
    {
      "reference_id": "REF-61",
      "author": [
        "Microsoft"
      ],
      "title": "Understanding DEP as a mitigation technology part 1",
      "url": "https://msrc.microsoft.com/blog/2009/06/understanding-dep-as-a-mitigation-technology-part-1/",
      "url_date": "2023-04-07"
    },
    {
      "reference_id": "REF-76",
      "author": [
        "Sean Barnum",
        "Michael Gegick"
      ],
      "title": "Least Privilege",
      "url": "https://web.archive.org/web/20211209014121/https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/least-privilege",
      "publication_year": "2005",
      "publication_month": "--09",
      "publication_day": "---14",
      "url_date": "2023-04-07"
    },
    {
      "section": "Chapter 3, \"Nonexecutable Stack\", Page 76",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "Chapter 5, \"Protection Mechanisms\", Page 189",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "section": "Chapter 8, \"C String Handling\", Page 388",
      "reference_id": "REF-62",
      "author": [
        "Mark Dowd",
        "John McDonald",
        "Justin Schuh"
      ],
      "title": "The Art of Software Security Assessment",
      "publication_year": "2006",
      "publisher": "Addison Wesley",
      "edition": "1st Edition"
    },
    {
      "reference_id": "REF-64",
      "author": [
        "Grant Murphy"
      ],
      "title": "Position Independent Executables (PIE)",
      "url": "https://www.redhat.com/en/blog/position-independent-executables-pie",
      "publication_year": "2012",
      "publication_month": "--11",
      "publication_day": "---28",
      "publisher": "Red Hat",
      "url_date": "2023-04-07"
    },
    {
      "section": "ASCRM-CWE-120",
      "reference_id": "REF-961",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Reliability Measure (ASCRM)",
      "url": "http://www.omg.org/spec/ASCRM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    },
    {
      "section": "ASCSM-CWE-120",
      "reference_id": "REF-962",
      "author": [
        "Object Management Group (OMG)"
      ],
      "title": "Automated Source Code Security Measure (ASCSM)",
      "url": "http://www.omg.org/spec/ASCSM/1.0/",
      "publication_year": "2016",
      "publication_month": "--01"
    },
    {
      "reference_id": "REF-1332",
      "author": [
        "John Richard Moser"
      ],
      "title": "Prelink and address space randomization",
      "url": "https://lwn.net/Articles/190139/",
      "publication_year": "2006",
      "publication_month": "--07",
      "publication_day": "---05",
      "url_date": "2023-04-26"
    },
    {
      "reference_id": "REF-1333",
      "author": [
        "Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh"
      ],
      "title": "Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR",
      "url": "http://www.cs.ucr.edu/~nael/pubs/micro16.pdf",
      "publication_year": "2016",
      "url_date": "2023-04-26"
    },
    {
      "reference_id": "REF-1334",
      "author": [
        "D3FEND"
      ],
      "title": "Stack Frame Canary Validation (D3-SFCV)",
      "url": "https://d3fend.mitre.org/technique/d3f:StackFrameCanaryValidation/",
      "publication_year": "2023",
      "url_date": "2023-04-26"
    },
    {
      "reference_id": "REF-1335",
      "author": [
        "D3FEND"
      ],
      "title": "Segment Address Offset Randomization (D3-SAOR)",
      "url": "https://d3fend.mitre.org/technique/d3f:SegmentAddressOffsetRandomization/",
      "publication_year": "2023",
      "url_date": "2023-04-26"
    },
    {
      "reference_id": "REF-1336",
      "author": [
        "D3FEND"
      ],
      "title": "Process Segment Execution Prevention (D3-PSEP)",
      "url": "https://d3fend.mitre.org/technique/d3f:ProcessSegmentExecutionPrevention/",
      "publication_year": "2023",
      "url_date": "2023-04-26"
    },
    {
      "section": "Memory information leaks",
      "reference_id": "REF-1337",
      "author": [
        "Alexander Sotirov and Mark Dowd"
      ],
      "title": "Bypassing Browser Memory Protections: Setting back browser security by 10 years",
      "url": "https://www.blackhat.com/presentations/bh-usa-08/Sotirov_Dowd/bh08-sotirov-dowd.pdf",
      "publication_year": "2008",
      "url_date": "2023-04-26"
    }
  ],
  "content_history": {
    "submission": {
      "submission_name": "PLOVER",
      "submission_date": "2006-07-19"
    },
    "modification": [
      {
        "modification_name": "Eric Dalci",
        "modification_organization": "Cigital",
        "modification_date": "2008-07-01",
        "modification_comment": "updated Time_of_Introduction"
      },
      {
        "modification_organization": "KDM Analytics",
        "modification_date": "2008-08-01",
        "modification_comment": "added/updated white box definitions"
      },
      {
        "modification_organization": "Veracode",
        "modification_date": "2008-08-15",
        "modification_comment": "Suggested OWASP Top Ten 2004 mapping"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-09-08",
        "modification_comment": "updated Alternate_Terms, Applicable_Platforms, Common_Consequences, Relationships, Observed_Example, Other_Notes, Taxonomy_Mappings, Weakness_Ordinalities"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-10",
        "modification_comment": "Changed name and description to more clearly emphasize the \"classic\" nature of the overflow."
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-10-14",
        "modification_comment": "updated Alternate_Terms, Description, Name, Other_Notes, Terminology_Notes"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2008-11-24",
        "modification_comment": "updated Other_Notes, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-01-12",
        "modification_comment": "updated Common_Consequences, Other_Notes, Potential_Mitigations, References, Relationship_Notes, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-07-27",
        "modification_comment": "updated Other_Notes, Potential_Mitigations, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2009-10-29",
        "modification_comment": "updated Common_Consequences, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-02-16",
        "modification_comment": "updated Applicable_Platforms, Common_Consequences, Demonstrative_Examples, Detection_Factors, Potential_Mitigations, References, Related_Attack_Patterns, Relationships, Taxonomy_Mappings, Time_of_Introduction, Type"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-04-05",
        "modification_comment": "updated Demonstrative_Examples, Related_Attack_Patterns"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-06-21",
        "modification_comment": "updated Common_Consequences, Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-09-27",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2010-12-13",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-03-29",
        "modification_comment": "updated Demonstrative_Examples, Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-01",
        "modification_comment": "updated Common_Consequences"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-06-27",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2011-09-13",
        "modification_comment": "updated Potential_Mitigations, References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-05-11",
        "modification_comment": "updated References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2012-10-30",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-02-18",
        "modification_comment": "updated Potential_Mitigations, References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2014-07-30",
        "modification_comment": "updated Detection_Factors, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2017-11-08",
        "modification_comment": "updated Applicable_Platforms, Causal_Nature, Demonstrative_Examples, Likelihood_of_Exploit, References, Relationships, Taxonomy_Mappings, White_Box_Definitions"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2018-03-27",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-01-03",
        "modification_comment": "updated References, Relationships, Taxonomy_Mappings"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2019-06-20",
        "modification_comment": "updated Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-02-24",
        "modification_comment": "updated Potential_Mitigations, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-06-25",
        "modification_comment": "updated Common_Consequences, Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-08-20",
        "modification_comment": "updated Alternate_Terms, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2020-12-10",
        "modification_comment": "updated Demonstrative_Examples, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-03-15",
        "modification_comment": "updated Demonstrative_Examples"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2021-07-20",
        "modification_comment": "updated Potential_Mitigations"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2022-10-13",
        "modification_comment": "updated References"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2023-01-31",
        "modification_comment": "updated Common_Consequences, Description"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2023-04-27",
        "modification_comment": "updated Potential_Mitigations, References, Relationships"
      },
      {
        "modification_name": "CWE Content Team",
        "modification_organization": "MITRE",
        "modification_date": "2023-06-29",
        "modification_comment": "updated Mapping_Notes"
      }
    ],
    "previous_entry_name": [
      {
        "text": "Unbounded Transfer ('Classic Buffer Overflow')",
        "date": "2008-10-14"
      }
    ]
  },
  "weakness_ordinalities": [
    {
      "ordinality": "Resultant"
    },
    {
      "ordinality": "Primary"
    }
  ],
  "alternate_terms": [
    {
      "term": "Classic Buffer Overflow",
      "description": "This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques."
    },
    {
      "term": "Unbounded Transfer"
    }
  ],
  "detection_methods": [
    {
      "detection_method_id": "DM-1",
      "method": "Automated Static Analysis",
      "description": "\n                  <xhtml:p>This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.</xhtml:p>\n                  <xhtml:p>Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.</xhtml:p>\n               ",
      "effectiveness": "High",
      "effectiveness_notes": "Detection techniques for buffer-related errors are more mature than for most other weakness types."
    },
    {
      "detection_method_id": "DM-2",
      "method": "Automated Dynamic Analysis",
      "description": "This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
    },
    {
      "detection_method_id": "DM-9",
      "method": "Manual Analysis",
      "description": "Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large."
    },
    {
      "method": "Automated Static Analysis - Binary or Bytecode",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Highly cost effective:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Bytecode Weakness Analysis - including disassembler + source code weakness analysis</xhtml:li>\n                           <xhtml:li>Binary Weakness Analysis - including disassembler + source code weakness analysis</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Manual Static Analysis - Binary or Bytecode",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Binary / Bytecode disassembler - then use manual analysis for vulnerabilities &amp; anomalies</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Dynamic Analysis with Automated Results Interpretation",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Web Application Scanner</xhtml:li>\n                           <xhtml:li>Web Services Scanner</xhtml:li>\n                           <xhtml:li>Database Scanners</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Dynamic Analysis with Manual Results Interpretation",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Fuzz Tester</xhtml:li>\n                           <xhtml:li>Framework-based Fuzzer</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Manual Static Analysis - Source Code",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Focused Manual Spotcheck - Focused manual analysis of source</xhtml:li>\n                           <xhtml:li>Manual Source Code Review (not inspections)</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "SOAR Partial"
    },
    {
      "method": "Automated Static Analysis - Source Code",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Highly cost effective:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Source code Weakness Analyzer</xhtml:li>\n                           <xhtml:li>Context-configured Source Code Weakness Analyzer</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "High"
    },
    {
      "method": "Architecture or Design Review",
      "description": "\n                  <xhtml:p>According to SOAR, the following detection techniques may be useful:</xhtml:p>\n                  <xhtml:div style=\"margin-left:1em;\">\n                     <xhtml:div>Highly cost effective:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Formal Methods / Correct-By-Construction</xhtml:li>\n                        </xhtml:ul>\n                     <xhtml:div>Cost effective for partial coverage:</xhtml:div>\n                        <xhtml:ul>\n                           <xhtml:li>Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)</xhtml:li>\n                        </xhtml:ul>\n                  </xhtml:div>\n               ",
      "effectiveness": "High"
    }
  ],
  "taxonomy_mappings": [
    {
      "taxonomy_name": "PLOVER",
      "entry_name": "Unbounded Transfer ('classic overflow')"
    },
    {
      "taxonomy_name": "7 Pernicious Kingdoms",
      "entry_name": "Buffer Overflow"
    },
    {
      "taxonomy_name": "CLASP",
      "entry_name": "Buffer overflow"
    },
    {
      "taxonomy_name": "OWASP Top Ten 2004",
      "entry_name": "Unvalidated Input",
      "entry_id": "A1",
      "mapping_fit": "CWE More Specific"
    },
    {
      "taxonomy_name": "OWASP Top Ten 2004",
      "entry_name": "Buffer Overflows",
      "entry_id": "A5",
      "mapping_fit": "CWE More Specific"
    },
    {
      "taxonomy_name": "CERT C Secure Coding",
      "entry_name": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
      "entry_id": "STR31-C",
      "mapping_fit": "Exact"
    },
    {
      "taxonomy_name": "WASC",
      "entry_name": "Buffer Overflow",
      "entry_id": "7"
    },
    {
      "taxonomy_name": "Software Fault Patterns",
      "entry_name": "Faulty Buffer Access",
      "entry_id": "SFP8"
    },
    {
      "taxonomy_name": "OMG ASCSM",
      "entry_id": "ASCSM-CWE-120"
    },
    {
      "taxonomy_name": "OMG ASCRM",
      "entry_id": "ASCRM-CWE-120"
    }
  ],
  "related_attack_patterns": [
    "10",
    "100",
    "14",
    "24",
    "42",
    "44",
    "45",
    "46",
    "47",
    "67",
    "8",
    "9",
    "92"
  ],
  "notes": [
    {
      "type": "Relationship",
      "text": "At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them."
    },
    {
      "type": "Terminology",
      "text": "Many issues that are now called \"buffer overflows\" are substantively different than the \"classic\" overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported."
    }
  ],
  "affected_resources": [
    "Memory"
  ],
  "functional_areas": [
    "Memory Management"
  ]
}
